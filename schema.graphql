schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  userFindById(_id: MongoID!): User
  userFindByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsUserInput): [User!]!
  userFindOne(
    """Filter by fields"""
    filter: FilterFindOneUserInput
    skip: Int
    sort: SortFindOneUserInput
  ): User
  userFindMany(
    """Filter by fields"""
    filter: FilterFindManyUserInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyUserInput
  ): [User!]!
  userCount(
    """Filter by fields"""
    filter: FilterCountUserInput
  ): Int
  userConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int
    """Forward pagination argument for returning at most first edges"""
    after: String
    """Backward pagination argument for returning at most last edges"""
    last: Int
    """Backward pagination argument for returning at most last edges"""
    before: String
    """Filter by fields"""
    filter: FilterFindManyUserInput
    """Sort argument for data ordering"""
    sort: SortConnectionUserEnum = _ID_DESC
  ): UserConnection
  userPagination(
    """Page number for displaying"""
    page: Int
    perPage: Int = 20
    """Filter by fields"""
    filter: FilterFindManyUserInput
    sort: SortFindManyUserInput
  ): UserPagination
  launchesAttendedFindById(_id: MongoID!): LaunchesAttended
  launchesAttendedFindByIds(_ids: [MongoID!]!, limit: Int = 100, sort: SortFindByIdsLaunchesAttendedInput): [LaunchesAttended!]!
  launchesAttendedFindOne(
    """Filter by fields"""
    filter: FilterFindOneLaunchesAttendedInput
    skip: Int
    sort: SortFindOneLaunchesAttendedInput
  ): LaunchesAttended
  launchesAttendedFindMany(
    """Filter by fields"""
    filter: FilterFindManyLaunchesAttendedInput
    skip: Int
    limit: Int = 100
    sort: SortFindManyLaunchesAttendedInput
  ): [LaunchesAttended!]!
  launchesAttendedCount(
    """Filter by fields"""
    filter: FilterCountLaunchesAttendedInput
  ): Int
  launchesAttendedConnection(
    """Forward pagination argument for returning at most first edges"""
    first: Int
    """Forward pagination argument for returning at most first edges"""
    after: String
    """Backward pagination argument for returning at most last edges"""
    last: Int
    """Backward pagination argument for returning at most last edges"""
    before: String
    """Filter by fields"""
    filter: FilterFindManyLaunchesAttendedInput
    """Sort argument for data ordering"""
    sort: SortConnectionLaunchesAttendedEnum = _ID_DESC
  ): LaunchesAttendedConnection
  launchesAttendedPagination(
    """Page number for displaying"""
    page: Int
    perPage: Int = 20
    """Filter by fields"""
    filter: FilterFindManyLaunchesAttendedInput
    sort: SortFindManyLaunchesAttendedInput
  ): LaunchesAttendedPagination
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]
    """limit the nuber of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [users_order_by!]
    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]
    """limit the nuber of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [users_order_by!]
    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
  capsules(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  capsulesPast(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  capsulesUpcoming(find: CapsulesFind, limit: Int, offset: Int, order: String, sort: String): [Capsule]
  capsule(id: ID!): Capsule
  company: Info
  cores(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  coresPast(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  coresUpcoming(find: CoresFind, limit: Int, offset: Int, order: String, sort: String): [Core]
  core(id: ID!): Core
  dragons(limit: Int, offset: Int): [Dragon]
  dragon(id: ID!): Dragon
  histories(find: HistoryFind, limit: Int, offset: Int, order: String, sort: String): [History]
  historiesResult(find: HistoryFind, limit: Int, offset: Int, order: String, sort: String): HistoriesResult
  history(id: ID!): History
  landpads(limit: Int, offset: Int): [Landpad]
  landpad(id: ID!): Landpad
  launches(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launchesPast(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launchesPastResult(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): LaunchesPastResult
  launchesUpcoming(find: LaunchFind, limit: Int, offset: Int, order: String, sort: String): [Launch]
  launch(id: ID!): Launch
  launchLatest(offset: Int): Launch
  launchNext(offset: Int): Launch
  launchpads(limit: Int, offset: Int): [Launchpad]
  launchpad(id: ID!): Launchpad
  missions(find: MissionsFind, limit: Int, offset: Int): [Mission]
  missionsResult(find: MissionsFind, limit: Int, offset: Int): MissionResult
  mission(id: ID!): Mission
  payloads(find: PayloadsFind, limit: Int, offset: Int, order: String, sort: String): [Payload]
  payload(id: ID!): Payload
  roadster: Roadster
  rockets(limit: Int, offset: Int): [Rocket]
  rocketsResult(limit: Int, offset: Int): RocketsResult
  rocket(id: ID!): Rocket
  ships(find: ShipsFind, limit: Int, offset: Int, order: String, sort: String): [Ship]
  shipsResult(find: ShipsFind, limit: Int, offset: Int, order: String, sort: String): ShipsResult
  ship(id: ID!): Ship
}

type Mutation {
  """Create one document with mongoose defaults, setters, hooks and validation"""
  userCreateOne(record: CreateOneUserInput!): CreateOneUserPayload
  """Creates Many documents with mongoose defaults, setters, hooks and validation"""
  userCreateMany(records: [CreateManyUserInput!]!): CreateManyUserPayload
  """Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."""
  userUpdateById(_id: MongoID!, record: UpdateByIdUserInput!): UpdateByIdUserPayload
  """Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."""
  userUpdateOne(
    record: UpdateOneUserInput!
    """Filter by fields"""
    filter: FilterUpdateOneUserInput
    sort: SortUpdateOneUserInput
    skip: Int
  ): UpdateOneUserPayload
  """Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. """
  userUpdateMany(
    record: UpdateManyUserInput!
    """Filter by fields"""
    filter: FilterUpdateManyUserInput
    sort: SortUpdateManyUserInput
    skip: Int
    limit: Int = 100
  ): UpdateManyUserPayload
  """Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document."""
  userRemoveById(_id: MongoID!): RemoveByIdUserPayload
  """Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document."""
  userRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneUserInput
    sort: SortRemoveOneUserInput
  ): RemoveOneUserPayload
  """Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. """
  userRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyUserInput!
    limit: Int = 100
  ): RemoveManyUserPayload
  """Create one document with mongoose defaults, setters, hooks and validation"""
  launchesAttendedCreateOne(record: CreateOneLaunchesAttendedInput!): CreateOneLaunchesAttendedPayload
  """Creates Many documents with mongoose defaults, setters, hooks and validation"""
  launchesAttendedCreateMany(records: [CreateManyLaunchesAttendedInput!]!): CreateManyLaunchesAttendedPayload
  """Update one document: 1) Retrieve one document by findById. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."""
  launchesAttendedUpdateById(_id: MongoID!, record: UpdateByIdLaunchesAttendedInput!): UpdateByIdLaunchesAttendedPayload
  """Update one document: 1) Retrieve one document via findOne. 2) Apply updates to mongoose document. 3) Mongoose applies defaults, setters, hooks and validation. 4) And save it."""
  launchesAttendedUpdateOne(
    record: UpdateOneLaunchesAttendedInput!
    """Filter by fields"""
    filter: FilterUpdateOneLaunchesAttendedInput
    sort: SortUpdateOneLaunchesAttendedInput
    skip: Int
  ): UpdateOneLaunchesAttendedPayload
  """Update many documents without returning them: Use Query.update mongoose method. Do not apply mongoose defaults, setters, hooks and validation. """
  launchesAttendedUpdateMany(
    record: UpdateManyLaunchesAttendedInput!
    """Filter by fields"""
    filter: FilterUpdateManyLaunchesAttendedInput
    sort: SortUpdateManyLaunchesAttendedInput
    skip: Int
    limit: Int = 100
  ): UpdateManyLaunchesAttendedPayload
  """Remove one document: 1) Retrieve one document and remove with hooks via findByIdAndRemove. 2) Return removed document."""
  launchesAttendedRemoveById(_id: MongoID!): RemoveByIdLaunchesAttendedPayload
  """Remove one document: 1) Remove with hooks via findOneAndRemove. 2) Return removed document."""
  launchesAttendedRemoveOne(
    """Filter by fields"""
    filter: FilterRemoveOneLaunchesAttendedInput
    sort: SortRemoveOneLaunchesAttendedInput
  ): RemoveOneLaunchesAttendedPayload
  """Remove many documents without returning them: Use Query.remove mongoose method. Do not apply mongoose defaults, setters, hooks and validation. """
  launchesAttendedRemoveMany(
    """Filter by fields"""
    filter: FilterRemoveManyLaunchesAttendedInput!
    limit: Int = 100
  ): RemoveManyLaunchesAttendedPayload
  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response
  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!
    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response
  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response
}

type User {
  name: String
  _id: MongoID!
}

"""The `ID` scalar type represents a unique MongoDB identifier in collection. MongoDB by default use 12-byte ObjectId value (https://docs.mongodb.com/manual/reference/bson-types/#objectid). But MongoDB also may accepts string or integer as correct values for _id field."""
scalar MongoID

enum SortFindByIdsUserInput {
  _ID_ASC
  _ID_DESC
}

input FilterFindOneUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneUserOperatorsInput
  OR: [FilterFindOneUserInput!]
  AND: [FilterFindOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneUserOperatorsInput {
  _id: FilterFindOneUser_idOperatorsInput
}

input FilterFindOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindOneUserInput {
  _ID_ASC
  _ID_DESC
}

input FilterFindManyUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyUserOperatorsInput
  OR: [FilterFindManyUserInput!]
  AND: [FilterFindManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyUserOperatorsInput {
  _id: FilterFindManyUser_idOperatorsInput
}

input FilterFindManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindManyUserInput {
  _ID_ASC
  _ID_DESC
}

input FilterCountUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountUserOperatorsInput
  OR: [FilterCountUserInput!]
  AND: [FilterCountUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountUserOperatorsInput {
  _id: FilterCountUser_idOperatorsInput
}

input FilterCountUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

"""A connection to a list of items."""
type UserConnection {
  """Total object count."""
  count: Int!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Information to aid in pagination."""
  edges: [UserEdge!]!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: String
  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

"""An edge in a connection."""
type UserEdge {
  """The item at the end of the edge"""
  node: User!
  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionUserEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type UserPagination {
  """Total object count."""
  count: Int
  """Array of objects."""
  items: [User!]
  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type PaginationInfo {
  currentPage: Int!
  perPage: Int!
  pageCount: Int
  itemCount: Int
  hasNextPage: Boolean
  hasPreviousPage: Boolean
}

type LaunchesAttended {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID!
}

enum SortFindByIdsLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

input FilterFindOneLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindOneLaunchesAttendedOperatorsInput
  OR: [FilterFindOneLaunchesAttendedInput!]
  AND: [FilterFindOneLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindOneLaunchesAttendedOperatorsInput {
  _id: FilterFindOneLaunchesAttended_idOperatorsInput
}

input FilterFindOneLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindOneLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

input FilterFindManyLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterFindManyLaunchesAttendedOperatorsInput
  OR: [FilterFindManyLaunchesAttendedInput!]
  AND: [FilterFindManyLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterFindManyLaunchesAttendedOperatorsInput {
  _id: FilterFindManyLaunchesAttended_idOperatorsInput
}

input FilterFindManyLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortFindManyLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

input FilterCountLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterCountLaunchesAttendedOperatorsInput
  OR: [FilterCountLaunchesAttendedInput!]
  AND: [FilterCountLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterCountLaunchesAttendedOperatorsInput {
  _id: FilterCountLaunchesAttended_idOperatorsInput
}

input FilterCountLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

"""A connection to a list of items."""
type LaunchesAttendedConnection {
  """Total object count."""
  count: Int!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """Information to aid in pagination."""
  edges: [LaunchesAttendedEdge!]!
}

"""An edge in a connection."""
type LaunchesAttendedEdge {
  """The item at the end of the edge"""
  node: LaunchesAttended!
  """A cursor for use in pagination"""
  cursor: String!
}

enum SortConnectionLaunchesAttendedEnum {
  _ID_DESC
  _ID_ASC
}

"""List of items with pagination."""
type LaunchesAttendedPagination {
  """Total object count."""
  count: Int
  """Array of objects."""
  items: [LaunchesAttended!]
  """Information to aid in pagination."""
  pageInfo: PaginationInfo!
}

type CreateOneUserPayload {
  """Document ID"""
  recordId: MongoID
  """Created document"""
  record: User
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

interface ErrorInterface {
  """Generic error message"""
  message: String
}

input CreateOneUserInput {
  name: String
}

type CreateManyUserPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!
  """Created documents"""
  records: [User!]
  """Number of created documents"""
  createdCount: Int!
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input CreateManyUserInput {
  name: String
}

type UpdateByIdUserPayload {
  """Document ID"""
  recordId: MongoID
  """Updated document"""
  record: User
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateByIdUserInput {
  name: String
}

type UpdateOneUserPayload {
  """Document ID"""
  recordId: MongoID
  """Updated document"""
  record: User
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateOneUserInput {
  name: String
}

input FilterUpdateOneUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneUserOperatorsInput
  OR: [FilterUpdateOneUserInput!]
  AND: [FilterUpdateOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneUserOperatorsInput {
  _id: FilterUpdateOneUser_idOperatorsInput
}

input FilterUpdateOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateOneUserInput {
  _ID_ASC
  _ID_DESC
}

type UpdateManyUserPayload {
  """Affected documents number"""
  numAffected: Int
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateManyUserInput {
  name: String
}

input FilterUpdateManyUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyUserOperatorsInput
  OR: [FilterUpdateManyUserInput!]
  AND: [FilterUpdateManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyUserOperatorsInput {
  _id: FilterUpdateManyUser_idOperatorsInput
}

input FilterUpdateManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateManyUserInput {
  _ID_ASC
  _ID_DESC
}

type RemoveByIdUserPayload {
  """Document ID"""
  recordId: MongoID
  """Removed document"""
  record: User
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

type RemoveOneUserPayload {
  """Document ID"""
  recordId: MongoID
  """Removed document"""
  record: User
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input FilterRemoveOneUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneUserOperatorsInput
  OR: [FilterRemoveOneUserInput!]
  AND: [FilterRemoveOneUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneUserOperatorsInput {
  _id: FilterRemoveOneUser_idOperatorsInput
}

input FilterRemoveOneUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortRemoveOneUserInput {
  _ID_ASC
  _ID_DESC
}

type RemoveManyUserPayload {
  """Affected documents number"""
  numAffected: Int
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input FilterRemoveManyUserInput {
  name: String
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyUserOperatorsInput
  OR: [FilterRemoveManyUserInput!]
  AND: [FilterRemoveManyUserInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyUserOperatorsInput {
  _id: FilterRemoveManyUser_idOperatorsInput
}

input FilterRemoveManyUser_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

type CreateOneLaunchesAttendedPayload {
  """Document ID"""
  recordId: MongoID
  """Created document"""
  record: LaunchesAttended
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input CreateOneLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
}

type CreateManyLaunchesAttendedPayload {
  """Documents IDs"""
  recordIds: [MongoID!]!
  """Created documents"""
  records: [LaunchesAttended!]
  """Number of created documents"""
  createdCount: Int!
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input CreateManyLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
}

type UpdateByIdLaunchesAttendedPayload {
  """Document ID"""
  recordId: MongoID
  """Updated document"""
  record: LaunchesAttended
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateByIdLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
}

type UpdateOneLaunchesAttendedPayload {
  """Document ID"""
  recordId: MongoID
  """Updated document"""
  record: LaunchesAttended
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateOneLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
}

input FilterUpdateOneLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateOneLaunchesAttendedOperatorsInput
  OR: [FilterUpdateOneLaunchesAttendedInput!]
  AND: [FilterUpdateOneLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateOneLaunchesAttendedOperatorsInput {
  _id: FilterUpdateOneLaunchesAttended_idOperatorsInput
}

input FilterUpdateOneLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateOneLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

type UpdateManyLaunchesAttendedPayload {
  """Affected documents number"""
  numAffected: Int
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input UpdateManyLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
}

input FilterUpdateManyLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterUpdateManyLaunchesAttendedOperatorsInput
  OR: [FilterUpdateManyLaunchesAttendedInput!]
  AND: [FilterUpdateManyLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterUpdateManyLaunchesAttendedOperatorsInput {
  _id: FilterUpdateManyLaunchesAttended_idOperatorsInput
}

input FilterUpdateManyLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortUpdateManyLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

type RemoveByIdLaunchesAttendedPayload {
  """Document ID"""
  recordId: MongoID
  """Removed document"""
  record: LaunchesAttended
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

type RemoveOneLaunchesAttendedPayload {
  """Document ID"""
  recordId: MongoID
  """Removed document"""
  record: LaunchesAttended
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input FilterRemoveOneLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveOneLaunchesAttendedOperatorsInput
  OR: [FilterRemoveOneLaunchesAttendedInput!]
  AND: [FilterRemoveOneLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveOneLaunchesAttendedOperatorsInput {
  _id: FilterRemoveOneLaunchesAttended_idOperatorsInput
}

input FilterRemoveOneLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

enum SortRemoveOneLaunchesAttendedInput {
  _ID_ASC
  _ID_DESC
}

type RemoveManyLaunchesAttendedPayload {
  """Affected documents number"""
  numAffected: Int
  """Error that may occur during operation. If you request this field in GraphQL query, you will receive typed error in payload; otherwise error will be provided in root `errors` field of GraphQL response."""
  error: ErrorInterface
}

input FilterRemoveManyLaunchesAttendedInput {
  spacexLaunchID: String
  userId: MongoID
  _id: MongoID
  """List of *indexed* fields that can be filtered via operators."""
  _operators: FilterRemoveManyLaunchesAttendedOperatorsInput
  OR: [FilterRemoveManyLaunchesAttendedInput!]
  AND: [FilterRemoveManyLaunchesAttendedInput!]
}

"""For performance reason this type contains only *indexed* fields."""
input FilterRemoveManyLaunchesAttendedOperatorsInput {
  _id: FilterRemoveManyLaunchesAttended_idOperatorsInput
}

input FilterRemoveManyLaunchesAttended_idOperatorsInput {
  gt: MongoID
  gte: MongoID
  lt: MongoID
  lte: MongoID
  ne: MongoID
  in: [MongoID]
  nin: [MongoID]
  exists: Boolean
}

type Subscription {
  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]
    """limit the nuber of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [users_order_by!]
    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]
    """limit the nuber of rows returned"""
    limit: Int
    """skip the first n rows. Use only with order_by"""
    offset: Int
    """sort the rows by one or more columns"""
    order_by: [users_order_by!]
    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  id
  """column name"""
  name
  """column name"""
  rocket
  """column name"""
  timestamp
  """column name"""
  twitter
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  id: order_by
  name: order_by
  rocket: order_by
  timestamp: order_by
  twitter: order_by
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc
  """in the ascending order, nulls first"""
  asc_nulls_first
  """in the ascending order, nulls last"""
  asc_nulls_last
  """in the descending order, nulls first"""
  desc
  """in the descending order, nulls first"""
  desc_nulls_first
  """in the descending order, nulls last"""
  desc_nulls_last
}

"""Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'."""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  id: uuid_comparison_exp
  name: String_comparison_exp
  rocket: String_comparison_exp
  timestamp: timestamptz_comparison_exp
  twitter: String_comparison_exp
}

"""expression to compare columns of type uuid. All fields are combined with logical 'AND'."""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

scalar uuid

"""expression to compare columns of type String. All fields are combined with logical 'AND'."""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""expression to compare columns of type timestamptz. All fields are combined with logical 'AND'."""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

scalar timestamptz

"""
columns and relationships of "users"
"""
type users {
  id: uuid!
  name: String
  rocket: String
  timestamp: timestamptz!
  twitter: String
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""aggregate max on columns"""
type users_max_fields {
  name: String
  rocket: String
  timestamp: timestamptz
  twitter: String
}

"""aggregate min on columns"""
type users_min_fields {
  name: String
  rocket: String
  timestamp: timestamptz
  twitter: String
}

input CapsulesFind {
  id: ID
  landings: Int
  mission: String
  original_launch: Date
  reuse_count: Int
  status: String
  type: String
}

scalar Date

type Capsule {
  id: ID
  landings: Int
  missions: [CapsuleMission]
  original_launch: Date
  reuse_count: Int
  status: String
  type: String
  dragon: Dragon
}

type CapsuleMission {
  flight: Int
  name: String
}

type Dragon {
  active: Boolean
  crew_capacity: Int
  description: String
  diameter: Distance
  dry_mass_kg: Int
  dry_mass_lb: Int
  first_flight: String
  heat_shield: DragonHeatShield
  height_w_trunk: Distance
  id: ID
  launch_payload_mass: Mass
  launch_payload_vol: Volume
  name: String
  orbit_duration_yr: Int
  pressurized_capsule: DragonPressurizedCapsule
  return_payload_mass: Mass
  return_payload_vol: Volume
  sidewall_angle_deg: Float
  thrusters: [DragonThrust]
  trunk: DragonTrunk
  type: String
  wikipedia: String
}

type Distance {
  feet: Float
  meters: Float
}

type DragonHeatShield {
  dev_partner: String
  material: String
  size_meters: Float
  temp_degrees: Int
}

type Mass {
  kg: Int
  lb: Int
}

type Volume {
  cubic_feet: Int
  cubic_meters: Int
}

type DragonPressurizedCapsule {
  payload_volume: Volume
}

type DragonThrust {
  amount: Int
  fuel_1: String
  fuel_2: String
  pods: Int
  thrust: Force
  type: String
}

type Force {
  kN: Float
  lbf: Float
}

type DragonTrunk {
  cargo: DragonTrunkCargo
  trunk_volume: Volume
}

type DragonTrunkCargo {
  solar_array: Int
  unpressurized_cargo: Boolean
}

type Info {
  ceo: String
  coo: String
  cto_propulsion: String
  cto: String
  employees: Int
  founded: Int
  founder: String
  headquarters: Address
  launch_sites: Int
  links: InfoLinks
  name: String
  summary: String
  test_sites: Int
  valuation: Float
  vehicles: Int
}

type Address {
  address: String
  city: String
  state: String
}

type InfoLinks {
  elon_twitter: String
  flickr: String
  twitter: String
  website: String
}

input CoresFind {
  asds_attempts: Int
  asds_landings: Int
  block: Int
  id: String
  missions: String
  original_launch: Date
  reuse_count: Int
  rtls_attempts: Int
  rtls_landings: Int
  status: String
  water_landing: Boolean
}

type Core {
  asds_attempts: Int
  asds_landings: Int
  block: Int
  id: ID
  missions: [CapsuleMission]
  original_launch: Date
  reuse_count: Int
  rtls_attempts: Int
  rtls_landings: Int
  status: String
  water_landing: Boolean
}

input HistoryFind {
  end: Date
  flight_number: Int
  id: ID
  start: Date
}

type History {
  details: String
  event_date_unix: Date
  event_date_utc: Date
  id: ID
  links: Link
  title: String
  flight: Launch
}

type Link {
  article: String
  reddit: String
  wikipedia: String
}

type Launch {
  details: String
  id: ID
  is_tentative: Boolean
  launch_date_local: Date
  launch_date_unix: Date
  launch_date_utc: Date
  launch_site: LaunchSite
  launch_success: Boolean
  launch_year: String
  links: LaunchLinks
  mission_id: [String]
  mission_name: String
  rocket: LaunchRocket
  static_fire_date_unix: Date
  static_fire_date_utc: Date
  telemetry: LaunchTelemetry
  tentative_max_precision: String
  upcoming: Boolean
  ships: [Ship]
}

type LaunchSite {
  site_id: String
  site_name_long: String
  site_name: String
}

type LaunchLinks {
  article_link: String
  flickr_images: [String]
  mission_patch_small: String
  mission_patch: String
  presskit: String
  reddit_campaign: String
  reddit_launch: String
  reddit_media: String
  reddit_recovery: String
  video_link: String
  wikipedia: String
}

type LaunchRocket {
  fairings: LaunchRocketFairings
  first_stage: LaunchRocketFirstStage
  rocket_name: String
  rocket_type: String
  rocket: Rocket
  second_stage: LaunchRocketSecondStage
}

type LaunchRocketFairings {
  recovered: Boolean
  recovery_attempt: Boolean
  reused: Boolean
  ship: String
}

type LaunchRocketFirstStage {
  cores: [LaunchRocketFirstStageCore]
}

type LaunchRocketFirstStageCore {
  block: Int
  core: Core
  flight: Int
  gridfins: Boolean
  land_success: Boolean
  landing_intent: Boolean
  landing_type: String
  landing_vehicle: String
  legs: Boolean
  reused: Boolean
}

type Rocket {
  active: Boolean
  boosters: Int
  company: String
  cost_per_launch: Int
  country: String
  description: String
  diameter: Distance
  engines: RocketEngines
  first_flight: Date
  first_stage: RocketFirstStage
  height: Distance
  id: ID
  landing_legs: RocketLandingLegs
  mass: Mass
  name: String
  payload_weights: [RocketPayloadWeight]
  second_stage: RocketSecondStage
  stages: Int
  success_rate_pct: Int
  type: String
  wikipedia: String
}

type RocketEngines {
  number: Int
  type: String
  version: String
  layout: String
  engine_loss_max: String
  propellant_1: String
  propellant_2: String
  thrust_sea_level: Force
  thrust_vacuum: Force
  thrust_to_weight: Float
}

type RocketFirstStage {
  burn_time_sec: Int
  engines: Int
  fuel_amount_tons: Float
  reusable: Boolean
  thrust_sea_level: Force
  thrust_vacuum: Force
}

type RocketLandingLegs {
  number: Int
  material: String
}

type RocketPayloadWeight {
  id: String
  kg: Int
  lb: Int
  name: String
}

type RocketSecondStage {
  burn_time_sec: Int
  engines: Int
  fuel_amount_tons: Float
  payloads: RocketSecondStagePayloads
  thrust: Force
}

type RocketSecondStagePayloads {
  option_1: String
  composite_fairing: RocketSecondStagePayloadCompositeFairing
}

type RocketSecondStagePayloadCompositeFairing {
  height: Distance
  diameter: Distance
}

type LaunchRocketSecondStage {
  block: Int
  payloads: [Payload]
}

type Payload {
  customers: [String]
  id: ID
  manufacturer: String
  nationality: String
  norad_id: [Int]
  orbit_params: PayloadOrbitParams
  orbit: String
  payload_mass_kg: Float
  payload_mass_lbs: Float
  payload_type: String
  reused: Boolean
}

type PayloadOrbitParams {
  apoapsis_km: Float
  arg_of_pericenter: Float
  eccentricity: Float
  epoch: Date
  inclination_deg: Float
  lifespan_years: Float
  longitude: Float
  mean_anomaly: Float
  mean_motion: Float
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  semi_major_axis_km: Float
}

type LaunchTelemetry {
  flight_club: String
}

type Ship {
  abs: Int
  active: Boolean
  attempted_landings: Int
  class: Int
  course_deg: Int
  home_port: String
  id: ID
  image: String
  imo: Int
  missions: [ShipMission]
  mmsi: Int
  model: String
  name: String
  position: ShipLocation
  roles: [String]
  speed_kn: Float
  status: String
  successful_landings: Int
  type: String
  url: String
  weight_kg: Int
  weight_lbs: Int
  year_built: Int
}

type ShipMission {
  flight: String
  name: String
}

type ShipLocation {
  latitude: Float
  longitude: Float
}

type HistoriesResult {
  result: Result
  data: [History]
}

type Result {
  totalCount: Int
}

type Landpad {
  attempted_landings: String
  details: String
  full_name: String
  id: ID
  landing_type: String
  location: Location
  status: String
  successful_landings: String
  wikipedia: String
}

type Location {
  latitude: Float
  longitude: Float
  name: String
  region: String
}

input LaunchFind {
  apoapsis_km: Float
  block: Int
  cap_serial: String
  capsule_reuse: String
  core_flight: Int
  core_reuse: String
  core_serial: String
  customer: String
  eccentricity: Float
  end: Date
  epoch: Date
  fairings_recovered: String
  fairings_recovery_attempt: String
  fairings_reuse: String
  fairings_reused: String
  fairings_ship: String
  gridfins: String
  id: ID
  inclination_deg: Float
  land_success: String
  landing_intent: String
  landing_type: String
  landing_vehicle: String
  launch_date_local: Date
  launch_date_utc: Date
  launch_success: String
  launch_year: String
  legs: String
  lifespan_years: Float
  longitude: Float
  manufacturer: String
  mean_motion: Float
  mission_id: String
  mission_name: String
  nationality: String
  norad_id: Int
  orbit: String
  payload_id: String
  payload_type: String
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  reused: String
  rocket_id: String
  rocket_name: String
  rocket_type: String
  second_stage_block: String
  semi_major_axis_km: Float
  ship: String
  side_core1_reuse: String
  side_core2_reuse: String
  site_id: String
  site_name_long: String
  site_name: String
  start: Date
  tbd: String
  tentative_max_precision: String
  tentative: String
}

type LaunchesPastResult {
  result: Result
  data: [Launch]
}

type Launchpad {
  attempted_launches: Int
  details: String
  id: ID
  location: Location
  name: String
  status: String
  successful_launches: Int
  vehicles_launched: [Rocket]
  wikipedia: String
}

input MissionsFind {
  id: ID
  manufacturer: String
  name: String
  payload_id: String
}

type Mission {
  description: String
  id: ID
  manufacturers: [String]
  name: String
  twitter: String
  website: String
  wikipedia: String
  payloads: [Payload]
}

type MissionResult {
  result: Result
  data: [Mission]
}

input PayloadsFind {
  apoapsis_km: Float
  customer: String
  eccentricity: Float
  epoch: Date
  inclination_deg: Float
  lifespan_years: Float
  longitude: Float
  manufacturer: String
  mean_motion: Float
  nationality: String
  norad_id: Int
  orbit: String
  payload_id: ID
  payload_type: String
  periapsis_km: Float
  period_min: Float
  raan: Float
  reference_system: String
  regime: String
  reused: Boolean
  semi_major_axis_km: Float
}

type Roadster {
  apoapsis_au: Float
  details: String
  earth_distance_km: Float
  earth_distance_mi: Float
  eccentricity: Float
  epoch_jd: Float
  inclination: Float
  launch_date_unix: Date
  launch_date_utc: Date
  launch_mass_kg: Int
  launch_mass_lbs: Int
  longitude: Float
  mars_distance_km: Float
  mars_distance_mi: Float
  name: String
  norad_id: Int
  orbit_type: Float
  periapsis_arg: Float
  periapsis_au: Float
  period_days: Float
  semi_major_axis_au: Float
  speed_kph: Float
  speed_mph: Float
  wikipedia: String
}

type RocketsResult {
  result: Result
  data: [Rocket]
}

input ShipsFind {
  id: ID
  name: String
  model: String
  type: String
  role: String
  active: Boolean
  imo: Int
  mmsi: Int
  abs: Int
  class: Int
  weight_lbs: Int
  weight_kg: Int
  year_built: Int
  home_port: String
  status: String
  speed_kn: Int
  course_deg: Int
  latitude: Float
  longitude: Float
  successful_landings: Int
  attempted_landings: Int
  mission: String
}

type ShipsResult {
  result: Result
  data: [Ship]
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!
  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  id: uuid
  name: String
  rocket: String
  timestamp: timestamptz
  twitter: String
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_pkey
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  id
  """column name"""
  name
  """column name"""
  rocket
  """column name"""
  timestamp
  """column name"""
  twitter
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  id: uuid
  name: String
  rocket: String
  timestamp: timestamptz
  twitter: String
}

"""conflict action"""
enum conflict_action {
  """ignore the insert on this row"""
  ignore
  """update the row with the given values"""
  update
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  name: order_by
  rocket: order_by
  timestamp: order_by
  twitter: order_by
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  name: order_by
  rocket: order_by
  timestamp: order_by
  twitter: order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

scalar ObjectID

type CoreMission {
  name: String
  flight: Int
}
